"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseOptions = parseOptions;
exports.createPlaceholder = exports.getOutputAndPublicPath = void 0;

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MIMES = {
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  png: "image/png",
  webp: "image/webp",
  avif: "image/avif"
};
const EXTS = {
  "image/jpeg": "jpg",
  "image/png": "png",
  "image/webp": "webp",
  "image/avif": "avif"
};

function parseOptions(loaderContext, options, defaults) {
  const outputContext = options.context || loaderContext.rootContext || loaderContext.options && loaderContext.options.context;
  const outputPlaceholder = Boolean(options.placeholder) || defaults.outputPlaceholder;
  const placeholderSize = parseInt(options.placeholderSize, 10) || defaults.placeholderSize; // JPEG and WEBP compression

  const quality = parseInt(options.quality, 10) || defaults.quality; // Useful when converting from PNG to JPG

  const background = options.background; // Progressive JPEG scan

  const progressive = options.progressive;
  const rotate = parseInt(options.rotate, 10) || defaults.rotate;
  let mime;
  let ext;

  if (options.format) {
    mime = MIMES[options.format];
    ext = EXTS[mime];
  } else {
    ext = _path.default.extname(loaderContext.resourcePath).replace(/\./, "");
    mime = MIMES[ext];
  }

  const name = (options.name || defaults.name).replace(/\[ext\]/gi, ext);
  const min = options.min !== undefined ? parseInt(options.min, 10) : undefined;
  const max = options.max !== undefined ? parseInt(options.max, 10) : undefined;
  const steps = options.steps === undefined ? defaults.steps : parseInt(options.steps, 10);
  let generatedSizes;

  if (typeof min === "number" && max) {
    generatedSizes = [];

    for (let step = 0; step < steps; step++) {
      const size = min + (max - min) / (steps - 1) * step;
      generatedSizes.push(Math.ceil(size));
    }
  }

  const esModule = options.esModule !== undefined ? options.esModule : defaults.esModule;
  const emitFile = options.emitFile !== undefined ? options.emitFile : defaults.emitFile;
  return {
    outputContext,
    outputPlaceholder,
    placeholderSize,
    quality,
    background,
    progressive,
    rotate,
    ext,
    mime,
    name,
    generatedSizes,
    esModule,
    emitFile
  };
}

const createPlaceholder = ({
  data
}, mime) => {
  return `"data:${mime};base64,${data.toString("base64")}"`;
};
/**
 * **Responsive Loader Paths**
 *
 * Returns the output and public path
 *
 * @method getOutputAndPublicPath
 *
 * @param {string} fileName
 * @param {Config} outputPath
 * @param {Config} publicPath
 *
 * @return {Config} Paths Result
 */


exports.createPlaceholder = createPlaceholder;

const getOutputAndPublicPath = (fileName, {
  outputPath: configOutputPath,
  publicPath: configPublicPath
}) => {
  let outputPath = fileName;

  if (configOutputPath) {
    if (typeof configOutputPath === "function") {
      outputPath = configOutputPath(fileName);
    } else {
      outputPath = _path.default.posix.join(configOutputPath, fileName);
    }
  }

  let publicPath = `__webpack_public_path__ + ${JSON.stringify(outputPath)}`;

  if (configPublicPath) {
    if (typeof configPublicPath === "function") {
      publicPath = configPublicPath(fileName);
    } else if (configPublicPath.endsWith("/")) {
      publicPath = configPublicPath + fileName;
    } else {
      publicPath = `${configPublicPath}/${fileName}`;
    }

    publicPath = JSON.stringify(publicPath);
  }

  return {
    outputPath,
    publicPath
  };
};

exports.getOutputAndPublicPath = getOutputAndPublicPath;